\chapter*{Version 2}
\label{chap:Technical CHallenges}
\renewcommand{\thesection}{\arabic{section}}
\setcounter{section}{0}

After my first attempts and some discussion with my supervisor I realised that the solution is to distribute the system and send the data wirelessly. This enables me to add additional sensors without having issues with the Wire library. However this increases the cost and complexity of each sensor slightly, since each sensor needs some sort of "brain", which handles the connection and communication. 
However it reduces the complexity of the construction and the entire solution drastically since it has single services talking to each other and not an entire blob of logic. 

\section{Attempt A - Local Client Server Network}

The communication was firstly achieved via WIFI since I know the protocol and can get it running swiftly. Also the esp32 I have been using has WIFI natively enabled. 
An issue with wireless communication is the synchronisation of the data flow. To simplify the process and due to lack of know how and time to achieve a correct synchronisation I will ignore it, while knowing the data might be time shifted. 
This might be an issue when visualising and analysing the data, but will be tackled then.

Furthermore for the communication via WIFI a simple "Client Server" protocol was used which has already been implement in ESP32 Micro-controllers.\cite{arduinoi4:online} \cite{ESP32Ser71:online}

Server Client Request: 
\begin{lstlisting}
String clientRequest(String input)
{
  Serial.println(input);
  String response = "\0";
  for (int i = 0; i < NUM_CLIENTS; i++)
  {
    WiFiClient client = server.available();
    client.setTimeout(50);
    if (client) {
      if (client.connected()) {
        client.println(input);
        data = client.readStringUntil('\r');  // received the server's answer
        Serial.println(data);
        if (data != "\0")
        {
          int Index = data.indexOf(':');
        
          CLIENT = data.substring(0, Index);
          ACTION = data.substring(Index + 1);
          Serial.println(data);
   
          if (CLIENT == "ACK")
          {
            response = ACTION;
          }

          //client.flush();
          //data = "\0";
        }
      }else{
        Serial.println("client not connected");
      }
    }
    else{
        Serial.println("client null or false");
      }
  }
\end{lstlisting}

Client Loop:

\begin{lstlisting}
void loop () {
  if (!client.connect(server, 80)) {
    while (WiFi.status() != WL_CONNECTED) {
      Serial.print(".");
      delay(500);
    }
    Serial.print("+");
    delay(100);
    return;
  }
  data = client.readStringUntil('\r');  // received the server's answer
  Serial.println(data);
  if (data != "\0")
  {
    int Index = data.indexOf(':');

    CLIENT = data.substring(0, Index);
    ACTION = data.substring(Index + 1);

    if (CLIENT == CLIENT_NAME)
    {
         client.println("ACK:" + getData());
      
    }else{
        client.println("\0");
    }

    client.flush();
    data = "\0";
  }
}
\end{lstlisting}

The Data will be sent 10 times per second for evaluation purposes. 
However I think this can be reduced, since we hopefully will not need that much data to determine how to user is positioned. This would enable us to aggregate the data on the devices, which is a benefit only achievable by the current configuration of "Smart-sensors".

The Data is saved onto an SD Card, this works well and enables to analyse the Data after measuring it for a while. This Concept worked quite well, however it has some major flaws. 

\section{Flaws of Attempt A}

The Idea of saving all the data locally came with the plan to have everything locally which then in a further step could be sent the a smartphone or a laptop without any internet. Maybe with Bluetooth or a local hotspot. 

During the development and testing of this concept, it turned out that the client server network was not very stable and it required much more hardware than I would have liked. 
The Server needed a few modules for it to work, as show below:


\begin{figure}[h]
  \begin{center}
\includegraphics[width=\linewidth]{images/CommunicationDiagrammExplenation.png}
  \end{center}
  \caption{Client Server Network}
  \label{fig:ClientServer}
\end{figure}

This does not look like much but both of these elements, the RTC and the SD Card reader, add an additional point of failure, are quite complex and need to be configured additionally. Additionally many different kinds of RTC and SD Card reader exists which do not have the exact same communication protocol, which is a big flaw, when trying to create something open-source and useful. All this felt like quite the hassle and I soon realised I need to find a new way to communicate.

Beside these technical issues the data transfer during the development phase, where Bluetooth or hotspot was available was quite awkward since the device need to be stopped and the data needed to be analysed in a separate step. 

\begin{figure}[h]
  \begin{center}
\includegraphics[width=0.5\textwidth]{images/CommunicationDiagrammLocal.png}
  \end{center}
  \caption{Communication Diagramm Local}
  \label{fig:CommunicationDiagrammLocal}
\end{figure}
After working with it for a while I tried to find a much simpler way, which is closer to the goal of a simple and affordable sensor set. To tackle the issues with the client server network, I first thought of using a simple http request, which would have a bit more overhead but would be more stable. This however did not feel right since I would be running a HTTP server on a microcontroller, which does not offer any benefits over using a "real" server. Furthermore HTTP has way to much overhead for such a scenario. I realised that the solution, was something I already was quite familiar with. A simple MQTT Broker. 



\section{Attempt B - Communication via MQTT}

After this first attempt I knew how to handle the message and date from the sensors which helped greatly. 
The Communication in my new attempt was handled with a simple \acrshort{mqtt} Broker (\gls{MQTT}), which can be setup for free within seconds. For my endeavours I used cloudmqtt.com which is completely free and easy to apply. 


\begin{figure}[h]
  \begin{center}
\includegraphics[width=0.8\textwidth]{images/CommunicationDiagrammMQTT.png}
  \end{center}
  \caption{Communication Diagramm MQTT}
  \label{fig:CommunicationDiagrammMQTT}
\end{figure}

MQTT uses a simple publish subscribe protocol which I have already implemented a few times.
Below you see the whole setup and loop code, which is almost readable thanks to helper functions:
\begin{lstlisting}
void setup() {
  Serial.begin(115200);
  Wire.begin();
  USERID = getRegisterdUserid();
  setupMPU();
  setupWifi();
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(callback);

  strcpy(fullsubtopic, TOPIC); 
  strcat(fullsubtopic, USERID);
  strcat(fullsubtopic, SUB);
  
  strcpy(fullpubtopic, TOPIC); 
  strcat(fullpubtopic, USERID);
  //strcat(fullpubtopic, PUB);
  
  while (!client.connected()) {
   reconnect();
  }
  startMillis = millis(); 
  getData();
}

void loop () {
  client.loop();
  currentMillis = millis();  //get the current "time" (actually the number of milliseconds since the program started)
  if (currentMillis - startMillis >= period)  //test whether the period has elapsed
  {
    Serial.println("trying to send");
    char * message = getMessage();
    publish(message);
    Serial.println(message);
    startMillis = currentMillis;  //IMPORTANT to save the start time of the current LED state.
  }
 getData();
 }
\end{lstlisting}

This loop collected the data into an average in "getData()" function
\begin{lstlisting}
void getData(){
  if(readByte(MPU6050_ADDRESS, INT_STATUS) & 0x01) {  // check if data ready interrupt
    readAccelData(accelCount);  // Read the x/y/z adc values
    getAres();
    ax = (float)accelCount[0]*aRes - accelBias[0];  // get actual g value, this depends on scale being set
    ay = (float)accelCount[1]*aRes - accelBias[1];   
    az = (float)accelCount[2]*aRes - accelBias[2];  
    readGyroData(gyroCount);  // Read the x/y/z adc values
    getGres();
    gx = (float)gyroCount[0]*gRes - gyroBias[0];  // get actual gyro value, this depends on scale being set
    gy = (float)gyroCount[1]*gRes - gyroBias[1];  
    gz = (float)gyroCount[2]*gRes - gyroBias[2];  
    tempCount = readTempData();  // Read the x/y/z adc values
    temperature = ((float) tempCount) / 340. + 36.53; // Temperature in degrees Centigrade
 
    accelVal[0] = ax;
    accelVal[1] = ay;
    accelVal[2] = az;
    gyroVal[0] = gx;
    gyroVal[1] = gy;
    gyroVal[2] = gz;
    setAvg();
    
   }
}
void setAvg(){
    for (int i = 0; i < 3; i++){
      avgAccelVal[i] = (avgAccelVal[i] + accelVal[i])/2;
      avgGyroVal[i] = (avgGyroVal[i] + gyroVal[i])/2;
  }
}
\end{lstlisting}
 and created a JSON from the collected data in the "getMessage()" function which was sent every second: 
\begin{lstlisting}
char* getMessage(){
  char* a = "{ \"id\": \"";
  char* b = "\", \"acc\":[";
  char* c= "], \"gyro\":[";
  char* d= "]}"; 
  char accelbuff[64];
  char gyrobuff[64];
  Serial.println("loading data to buffers");
  char* loc = accelbuff;
   size_t tempLen;
   int i = 0;
   for(i = 0; i < DIM(avgAccelVal)-1; ++i)
    {
        snprintf(loc, 12, "%f,", avgAccelVal[i]);
        tempLen = strlen(loc);
        loc += tempLen;
    }
    snprintf(loc, 12, "%f", avgAccelVal[i]);
   //snprintf(loc, 12, "%f", avgAccelVal[i+1]);
   tempLen = strlen(loc);
   loc += tempLen;
   loc = gyrobuff;
   for(i = 0; i < DIM(avgGyroVal)-1; ++i)
    {
        snprintf(loc, 12, "%f,", avgGyroVal[i]);
        tempLen = strlen(loc);
        loc += tempLen;
    }
  snprintf(loc, 12, "%f", avgGyroVal[i]);
  //snprintf(loc, 12, "%f", avgGyroVal[i+1]);
  tempLen = strlen(loc);
  loc += tempLen;
  strcpy(messagebuffer, a ); 
  strcat(messagebuffer, DEVICEID);
  strcat(messagebuffer, b);
  strcat(messagebuffer, accelbuff);
  strcat(messagebuffer, c);
  strcat(messagebuffer, gyrobuff);
  strcat(messagebuffer, d);
  return messagebuffer;
}
\end{lstlisting}
As you can see the creation of the message, was almost the most complex part of the implementation. This was due to the fact, that the "PubSubClient" Library \cite{knollear26:online}, used to communicate with the MQTT Broker, could not handle "arduino" strings and therefore needed char pointers, which are a quite complicated to work with. That is also why a grave error occurred in this function. The lines which are commented out, were my first implementation which work but give wrong data since it does not access to expected array or data.
This mistake was unfortunately only discovered when visualising the data, since C++ does not throw any errors when accessing items out of the array, and simply returns the values in the addresses accessed.
Nonetheless after some tinkering I finally managed to get a nice \acrshort{json} message (\gls{JSON}) over the MQTT Broker: 
\begin{lstlisting}
{ 
    "id": "SENSOR-XSZ", 
    "acc":[-0.003835,0.001486,0.056012],
    "gyro":[0.056012,0.240598,0.038814]
}
\end{lstlisting}

\acrshort{protobuff} (\gls{Protobuf}) would be a great alternative, which I will try to implement as well. Protobuf does take some time to set up but would simplify the data transfer greatly since bytes could be directly sent and would not need to be concatenated to a JSON.

Additionally I enabled all devices to be calibrated remotely. This since when I put these devices on I will need to calibrate them after they are set in position. This is quite a simple task with MQTT since the clients can simply subscribe to a topic, from which they get messages: 

\begin{lstlisting}
void callback(char* topic, byte* message, unsigned int length) {
  Serial.print("Message arrived on topic: ");
  Serial.print(topic);
  Serial.print(". Message: ");
  String command;
  
  for (int i = 0; i < length; i++) {
    Serial.print((char)message[i]);
    command += (char)message[i];
  }
  if(command == "calibrate"){
    calibrateMPU6050(gyroBias, accelBias); 
    // Calibrate gyro and accelerometers, load biases in bias registers  
    initMPU6050(); 
    Serial.println("MPU6050 initialized for active data mode....");
  }
}
\end{lstlisting}
This callback gets registered when connecting to the mqtt broker.

\subsection{Benefits Version 2}

The benefits of managing the messages via a MQTT Broker was, that I could get the messages and work with them from any device with an Internet connection. This means that any calculation heavy tasks can be done from a "real" computer which handles these much better. 

This also enabled me to visualise and analyse the data in real-time which made it much easier. 

Furthermore it also achieves the goal of being cheap and affordable. Since we now only need MPU6050 and microntrollers to send the data and this can be setup much easier than with an ESP32 "server".

This also means that there does not need to be any more logic on the devices itself since everything can be done from a Computer. Maybe some sort of vibration device will be added which however also can be activated via the MQTT Broker. 

The Fact that these sensors now can simply send data without knowing where they are or what exactly they are measuring might open quite a lot of doors. I will get further into that in the chapter "Prospects".

\subsection{Backdraws Version 2}

The Obvious backdraw is, that the sensors need to have a constant Internet connection. This is obviously not great, especially when we try to develop something for an every usage since we are somewhat bound to a single place. 

Furthermore if used as a product, these sensors would need to be registered first before usage, this does increase complexity for a first usage however simplifies setup greatly.


\input{Chapters/04_Version2/identifying_posture.tex}

\input{Chapters/04_Version2/Webapp.tex}


\section{Hardware}

The Implementation with MQTT not only simplifies the communication but also reduces the hardware complexity greatly. The only parts needed are an MPU6050 a vibration unit and some sort the micro-controller. Since MPU and vibration unit are suitable with almost any micro-controller there are almost no restrictions left. Additionally even the accelerometer and gyroscope hardware could be changed. The only restriction to analyse the data, is that the data is sent in the same JSON format. 

As a second prototype a different micro controller was used, which was smaller and worked with a small battery unit. This enabled me to already reduce the size of the sensor module. Any additional function like LED's for demonstration purposes can also simply be added and used in place of a vibration unit.

Currently the hardware all together costs, even when bought in Switzerland and as a single unit, about 20 CHF. When bought from china, still as single units, the price can be reduced to about 12 CHF. I would estimate that the price could be lowered further, when buying in bulk, to about 5 CHF.


\input{Chapters/04_Version2/techincal_difficulties.tex}
